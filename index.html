<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGI Era - Liquid Glass Instance</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        /* === 全局复位与变量 === */
        :root {
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.2);
            --text-main: #ffffff;
            --text-sub: rgba(255, 255, 255, 0.6);
            --accent: #2997ff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            color: var(--text-main);
            user-select: none;
        }

        /* === WebGL 画布 (背景层) === */
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1; /* 3D 场景层 */
        }

        /* === UI 层 (悬浮在 3D 之上) === */
        .ui-layer {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none; /* 让鼠标穿透 UI 操作 3D */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        /* === 玻璃拟态组件 === */
        .glass-card {
            pointer-events: auto; /* 恢复交互 */
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-top: 1px solid var(--glass-highlight);
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            max-width: 320px;
        }

        .glass-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.08);
        }

        /* 顶部导航 */
        .nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            font-weight: 600;
            font-size: 18px;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-dot {
            width: 8px; height: 8px;
            background: #00ff41;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ff41;
        }

        /* 底部内容 */
        .content-area {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        h1 { margin: 0 0 8px 0; font-size: 20px; font-weight: 500; }
        p { margin: 0; font-size: 14px; color: var(--text-sub); line-height: 1.5; }
        
        .btn {
            margin-top: 16px;
            background: #fff;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 100px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .btn:hover { opacity: 0.9; }

        /* 中心的文字 (被液态球遮挡) */
        .center-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 0; /* 在 3D 场景后面吗？不，我们在 3D 场景里画背景 */
            opacity: 0; /* 这里我们不需要 DOM 文字，因为 3D 场景里有光球 */
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="nav-bar">
            <div class="glass-card" style="padding: 12px 24px; border-radius: 100px;">
                <div class="logo">
                    <div class="status-dot"></div>
                    AGI Era <span style="opacity:0.5; font-weight:400;">OS 2.0</span>
                </div>
            </div>
        </div>

        <div class="content-area">
            <div class="glass-card">
                <h1>Neural Engine</h1>
                <p>Real-time fluid simulation powered by WebGL shader pipeline. Simulating refractive index of 1.52 (Glass).</p>
                <button class="btn">View Specs</button>
            </div>
            
            <div class="glass-card">
                <h1>Optical Flow</h1>
                <p>Dual-pass Gaussian blur applied to the background buffer for realistic depth of field.</p>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';

        // ==========================================
        // 1. 初始化引擎
        // ==========================================
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 4;

        // 场景分层
        const bgScene = new THREE.Scene();      // 背景层 (光球)
        const mainScene = new THREE.Scene();    // 主层 (液态玻璃)
        const postScene = new THREE.Scene();    // 后处理层 (Blur)
        const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // ==========================================
        // 2. 渲染目标 (Framebuffers)
        // ==========================================
        const rtParams = { 
            minFilter: THREE.LinearFilter, 
            magFilter: THREE.LinearFilter, 
            format: THREE.RGBAFormat,
            type: THREE.HalfFloatType // 使用半精度浮点以获得更好的 HDR 效果
        };
        
        // RT1: 纯净的背景
        const rtBackground = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);
        // RT2 & RT3: 用于 Ping-Pong 模糊 (降采样 1/2 以提高性能)
        const rtBlurA = new THREE.WebGLRenderTarget(window.innerWidth/2, window.innerHeight/2, rtParams);
        const rtBlurB = new THREE.WebGLRenderTarget(window.innerWidth/2, window.innerHeight/2, rtParams);

        // ==========================================
        // 3. 构建背景 (bgScene) - 那些漂亮的光斑
        // ==========================================
        const bgGroup = new THREE.Group();
        bgScene.add(bgGroup);

        // 创建 6 个浮动的彩色光球
        const geometryOrb = new THREE.SphereGeometry(1, 32, 32);
        const colors = [0x2997ff, 0xbf5af2, 0xff375f, 0x30d158, 0xff9f0a, 0x64d2ff];

        for(let i=0; i<6; i++) {
            const material = new THREE.MeshBasicMaterial({ color: colors[i] });
            const mesh = new THREE.Mesh(geometryOrb, material);
            
            // 随机位置和大小
            mesh.position.set(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 6,
                (Math.random() - 0.5) * 4 - 2
            );
            mesh.scale.setScalar(0.8 + Math.random());
            
            // 存储动画参数
            mesh.userData = {
                phase: Math.random() * Math.PI * 2,
                speed: 0.2 + Math.random() * 0.3
            };
            
            bgGroup.add(mesh);
        }

        // ==========================================
        // 4. 构建模糊 Shader (用于处理背景)
        // ==========================================
        const blurShader = {
            uniforms: {
                tDiffuse: { value: null },
                uResolution: { value: new THREE.Vector2() },
                uDirection: { value: new THREE.Vector2() } // (1,0) 水平 或 (0,1) 垂直
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 uResolution;
                uniform vec2 uDirection;
                varying vec2 vUv;

                // 高斯权重
                float weights[5];
                
                void main() {
                    weights[0] = 0.227027;
                    weights[1] = 0.1945946;
                    weights[2] = 0.1216216;
                    weights[3] = 0.054054;
                    weights[4] = 0.016216;

                    vec4 color = texture2D(tDiffuse, vUv) * weights[0];
                    vec2 off = uDirection / uResolution;

                    for(int i = 1; i < 5; i++) {
                        color += texture2D(tDiffuse, vUv + off * float(i)) * weights[i];
                        color += texture2D(tDiffuse, vUv - off * float(i)) * weights[i];
                    }
                    
                    gl_FragColor = color;
                }
            `
        };

        const blurMaterial = new THREE.ShaderMaterial({
            uniforms: THREE.UniformsUtils.clone(blurShader.uniforms),
            vertexShader: blurShader.vertexShader,
            fragmentShader: blurShader.fragmentShader,
            depthTest: false,
            depthWrite: false
        });

        const fullScreenQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), blurMaterial);
        postScene.add(fullScreenQuad);

        // ==========================================
        // 5. 构建液态玻璃 (mainScene) - 核心物理 Shader
        // ==========================================
        const glassShader = {
            uniforms: {
                uTexture: { value: null },      // 清晰背景
                uBlurTexture: { value: null },  // 模糊背景
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uTime: { value: 0 },
                uRefractPower: { value: 0.3 },  // 折射强度
                uDispersion: { value: 0.03 },   // 色散强度 (红蓝分离)
                uNoiseStrength: { value: 0.04 } // 噪点强度
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                uniform sampler2D uBlurTexture;
                uniform vec2 uResolution;
                uniform float uRefractPower;
                uniform float uDispersion;
                uniform float uNoiseStrength;
                uniform float uTime;

                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vViewPosition;

                // 随机噪点函数
                float rand(vec2 co){
                    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                }

                void main() {
                    // 1. 获取屏幕空间坐标
                    vec2 screenUV = gl_FragCoord.xy / uResolution;

                    // 2. 根据法线计算折射偏移
                    vec3 viewDir = normalize(vViewPosition);
                    // 简单的球面映射模拟
                    vec2 offset = vNormal.xy * uRefractPower * 0.5;

                    // 3. 色散采样 (Chromatic Aberration)
                    // 从模糊纹理中分别采样 R, G, B 通道，使用略微不同的偏移量
                    float r = texture2D(uBlurTexture, screenUV + offset * (1.0 + uDispersion)).r;
                    float g = texture2D(uBlurTexture, screenUV + offset * 1.0).g;
                    float b = texture2D(uBlurTexture, screenUV + offset * (1.0 - uDispersion)).b;
                    
                    vec3 color = vec3(r, g, b);

                    // 4. 菲涅尔效应 (边缘高光)
                    float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), 3.0);
                    color += vec3(1.0) * fresnel * 0.6; // 强高光

                    // 5. 内部光泽 (模拟厚度)
                    color += vec3(0.1, 0.1, 0.15) * (1.0 - fresnel);

                    // 6. 添加电影噪点 (Dithering)
                    float noise = (rand(screenUV * uTime) - 0.5) * uNoiseStrength;
                    color += noise;

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };

        const glassMaterial = new THREE.ShaderMaterial({
            uniforms: THREE.UniformsUtils.clone(glassShader.uniforms),
            vertexShader: glassShader.vertexShader,
            fragmentShader: glassShader.fragmentShader
        });

        // 创建高精度球体以便液态变形
        const sphereGeometry = new THREE.IcosahedronGeometry(1.5, 64);
        const sphere = new THREE.Mesh(sphereGeometry, glassMaterial);
        mainScene.add(sphere);

        // 保存原始顶点位置用于变形计算
        const originalPositions = sphereGeometry.attributes.position.clone();

        // ==========================================
        // 6. 动画循环 (Render Pipeline)
        // ==========================================
        const clock = new THREE.Clock();
        const simplex = new SimplexNoise();
        
        // 鼠标交互
        let mouseX = 0; 
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (e.clientY - window.innerHeight / 2) * 0.001;
        });

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            // --- A. 更新背景光球位置 ---
            bgGroup.children.forEach((mesh, i) => {
                mesh.position.x = Math.sin(time * mesh.userData.speed + mesh.userData.phase) * 5;
                mesh.position.y = Math.cos(time * mesh.userData.speed * 0.8 + mesh.userData.phase) * 3;
                mesh.rotation.z = time * 0.1;
            });

            // --- B. 液态变形逻辑 ---
            targetX += (mouseX - targetX) * 0.05;
            targetY += (mouseY - targetY) * 0.05;

            // 球体根据鼠标缓慢旋转
            sphere.rotation.y = time * 0.1 + targetX;
            sphere.rotation.x = targetY;

            // 顶点噪声位移
            const positionAttribute = sphereGeometry.attributes.position;
            const noiseSpeed = 0.5;
            const noiseAmp = 0.15; // 液体波动幅度

            for (let i = 0; i < positionAttribute.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(originalPositions, i);
                
                // 4D 噪声 (x,y,z,t)
                const noise = simplex.noise4d(
                    v.x * 0.8, 
                    v.y * 0.8, 
                    v.z * 0.8, 
                    time * noiseSpeed
                );

                v.multiplyScalar(1 + noise * noiseAmp);
                positionAttribute.setXYZ(i, v.x, v.y, v.z);
            }
            sphereGeometry.computeVertexNormals();
            positionAttribute.needsUpdate = true;


            // --- C. 渲染管线 (Pipeline) ---

            // Pass 1: 渲染背景 -> rtBackground
            renderer.setRenderTarget(rtBackground);
            renderer.clear();
            renderer.render(bgScene, camera);

            // Pass 2: 水平模糊 (rtBackground -> rtBlurA)
            blurMaterial.uniforms.tDiffuse.value = rtBackground.texture;
            blurMaterial.uniforms.uResolution.value.set(window.innerWidth/2, window.innerHeight/2);
            blurMaterial.uniforms.uDirection.value.set(2.0, 0.0); // 模糊半径
            renderer.setRenderTarget(rtBlurA);
            renderer.clear();
            renderer.render(postScene, orthoCamera);

            // Pass 3: 垂直模糊 (rtBlurA -> rtBlurB)
            blurMaterial.uniforms.tDiffuse.value = rtBlurA.texture;
            blurMaterial.uniforms.uDirection.value.set(0.0, 2.0); // 模糊半径
            renderer.setRenderTarget(rtBlurB);
            renderer.clear();
            renderer.render(postScene, orthoCamera);

            // Pass 4: 最终合成 (背景 + 液态玻璃) -> 屏幕
            renderer.setRenderTarget(null);
            renderer.clear();

            // 4.1 先画清晰的背景
            renderer.render(bgScene, camera);

            // 4.2 更新玻璃 Shader 参数
            glassMaterial.uniforms.uTexture.value = rtBackground.texture;
            glassMaterial.uniforms.uBlurTexture.value = rtBlurB.texture; // 使用完全模糊的纹理
            glassMaterial.uniforms.uTime.value = time;
            
            // 4.3 画液态玻璃
            renderer.render(mainScene, camera);
        }

        // 窗口大小自适应
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
            
            // 更新 render targets 大小
            rtBackground.setSize(width, height);
            rtBlurA.setSize(width/2, height/2);
            rtBlurB.setSize(width/2, height/2);
            
            // 更新 shader 分辨率
            glassMaterial.uniforms.uResolution.value.set(width, height);
        });

        animate();
    </script>
</body>
</html>
